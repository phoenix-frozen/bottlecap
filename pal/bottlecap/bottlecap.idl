struct tpm_rsakey_t {
	//TODO: placeholder data structure until I learn a bit more about TPMs

	//represents an RSA keypair data blob that can be loaded into the TPM
};

struct tpm_aeskey_t {
	//TODO: placeholder data structure until I learn a bit more about TPMs

	//represents an AES key that is bound/sealed to a TPM state, encrypted
	// with a key from a tpm_rsakey_t
};

struct tpm_encrypted_cap_t {
	tpm_encrypted_aeskey_t key; //{key}_[some TPM-bound RSA key]
	cap_t cap; //{cap}_key

	//represents a cap that is bound/sealed to a TPM state, encrypted
	// with a key from a tpm_rsakey_t
};

struct captable_header_t {
	uint32_t magic; //0x80771ECA

	//rsa cryptographic stuff; always 2048-bit RSA keys for TPM compatibility
	tpm_rsakey_t brk; //{Bottle Root Key}_SEK (sealed)
	tpm_rsakey_t bsk; //{Bottle Signing Key}_BRK (bound)
	tpm_rsakey_t brk_public; //to be given to cap issuers to send caps
	tpm_rsakey_t bsk_public; //to be given to cap issuers to check quotes

	//aes cryptographic stuff; always 128-bit AES
	tpm_aeskey_t  bek; //{Bottle Encryption Key}_SRK (bound)

	//bottle configuration stuff
	uint32_t   flags; //timed (that is, uses monotonic counters), migratable (off this TPM)
	uint32_t   size; //number of slots in the bottle

	//matching check
	uint256_t  captable_signature; //{main table}_BSK
	uint256_t  header_signature; //{prevous header fields}_BSK

	//TODO: need some kind of password-check field

	uint32_t magic; //0x909ACE17
};

struct cap_t {
	uint128_t key; //password is a AES-128 key, generated by issuer
	uint128_t issuer; //issuer's AES-128 key
	uint64_t  oid; //object-ID field, used by issuer
	uint64_t  expiry; //cap expiry time, in 64-bit Unix time, determined by issuer
	uint32_t  urights; //rights mask, used by issuer
	uint32_t  srights; //BottleCap rights word, determined by issuer
	//Note: expiry == 0 -> slot is empty
};

struct bottle_t {
	captable_header_t header; //bottle header structure
	uint128_t password; //password which will be XOR'd into BEK TODO: is this a good idea?
	cap_t table[]; //{Caps}_BEK
};

//TODO: do I need to deal with TPM ownership credential?
/* Note on attestations to remote verifiers
 * ----------------------------------------
 * Various keys, caps, etc, should all be bound to the correct TPM
 * configuration anyway, which means we shouldn't actually need to use TC
 * attestation directly to attest BottleCap: it will have been done implicitly.
 * (Modulo some version negotiation and distribution of valid hash tables.)
 */
/* Note on PCRs
 * ------------
 * On PC99:  * PCR17: Reset(4), Extend(4, 3, 2)
 *           * PCR18: Reset(4), Extend(4, 3, 2)
 *           * PCR19: Reset(4), Extend(3, 2)
 * On Intel: * PCR17: SINIT ACM module
 *           * PCR18: MLE
 *           * PCR19: Flicker extended MLE
 * On AMD:   * PCR17: SK
 *           * PCR18: Nothing.
 *           * PCR19: Flicker extended MLE
 * Plan of action: On AMD, ensure to extend the Intel-style MLE hash into
 *                 PCR18. (Can we then assert PCR17 == PCR18?)
 */
interface BottleCap {
	//BOTTLE CREATION/DELETION
	/**
	 * Initialises a new bottle, in the memory provided.
	 * bottle.header.size and bottle.header.flags should be filled in
	 * by the caller.
	 * 
	 * @param bottle Memory where the bottle is to be created.
	 * @return       Error code.
	 */
	int32_t bottle_init(in bottle_t bottle);
	/**
	 * Destroys the given bottle.
	 * At the moment simply zeros the relevant memory, but may in future
	 * reclaim resources consumed by this bottle, such as TPM monotonic
	 * counters.
	 * 
	 * @param bottle Memory where the bottle is to be created.
	 * @return       Error code.
	 */
	int32_t bottle_destroy(in bottle_t bottle);

	//BOTTLE STATE FUNCTIONS
	/**
	 * Returns the number of free slots in the bottle.
	 * 
	 * @param bottle The bottle to operate on.
	 * @param slots  The number of free slots in bottle.
	 * @return       Error code.
	 */
	int32_t bottle_query_free_slots(in bottle_t bottle, out uint32_t slots);
	/**
	 * Deletes all caps in the bottle whose expiry dates
	 * are less than or equal to time.
	 * 
	 * @param bottle The bottle to operate on.
	 * @param time   The current time.
	 * @param slots  The new number of free slots in the bottle.
	 * @return       Error code.
	 */
	int32_t bottle_expire(in bottle_t bottle, in uint64_t time, out uint32_t slots);

	//INTER-MACHINE BOTTLE MIGRATION FUNCTIONS
	/**
	 * Binds this bottle's BRK to a new TPM (including PCR values),
	 * allowing inter-machine migration.
	 * Does not change bottle in any way.
	 * 
	 * @param bottle The bottle to operate on.
	 * @param rsrk   The remote TPM's public SRK.
	 * @param brk    {BRK}_rSRK (TPM key blob)
	 * @return       Error code.
	 */
	int32_t bottle_export(in bottle_t bottle, in tpm_rsakey_t rsrk, out tpm_rsakey_t brk);
	/**
	 * Imports a bottle onto this machine: takes the bound BRK, and uses it to
	 * rewrite the bottle header so it is usable on this machine.
	 * 
	 * @param bottle The bottle to operate on.
	 * @param brk    {BRK}_SRK for this machine's TPM
	 * @return       Error code.
	 */
	int32_t bottle_import(in bottle_t bottle, in tpm_rsakey_t brk);

	//CAP INSERTION/DELETION FUNCTIONS
	/**
	 * Inserts a capability into the first free slot in the bottle.
	 * 
	 * @param bottle The bottle to operate on.
	 * @param cap    {The new cap.}_BRK (bound to PCR values)
	 * @param slot   The slot into which cap was inserted.
	 * @return        Error code.
	 */
	int32_t bottle_cap_add(in bottle_t bottle, in tpm_encrypted_cap_t cap, out uint32_t slot);
	/**
	 * Deletes a capability from the specified slot. If the slot is empty,
	 * this is a no-op.
	 * 
	 * @param bottle The bottle to operate on.
	 * @param slot   The slot to clear.
	 * @return       Error code.
	 */
	int32_t bottle_cap_delete(in bottle_t bottle, in uint32_t slot);

	//INTER-BOTTLE CAP MIGRATION
	/**
	 * Exports a capability for migration to another bottle. (The remote
	 * bottle uses bottle_cap_add to import it.)
	 * 
	 * @param bottle The bottle to operate on.
	 * @param slot   The slot containing the cap to export.
	 * @param rbrk   The public BRK for the bottle to export to.
	 * @param move   Whether to delete the original cap.
	 * @param cap    {Exported cap}_rBRK (bound to BottleCap PCR values)
	 * @return       Error code.
	 */
	int32_t bottle_cap_export(in bottle_t bottle, in uint32_t slot, in tpm_rsakey_t rbrk, in bool move, out tpm_encrypted_cap_t cap);

	//CAP INVOCATION FUNCTIONS
	//TODO: Needham-Schroeder (ie Kerberos) protocol
};
