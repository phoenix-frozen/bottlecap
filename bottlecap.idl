struct tpm_rsakey_t {
	//TODO: placeholder data structure until I learn a bit more about TPMs

	//represents an RSA keypair data blob that can be loaded into the TPM
};

struct tpm_aeskey_t {
	//TODO: placeholder data structure until I learn a bit more about TPMs

	//represents an AES key that is bound/sealed to a TPM state, encrypted
	// with a key from a tpm_rsakey_t
};

struct tpm_encrypted_cap_t {
	//TODO: placeholder data structure until I learn a bit more about TPMs

	//represents a cap that is bound/sealed to a TPM state, encrypted
	// with a key from a tpm_rsakey_t
};

struct captable_header_t {
	uint32_t magic; //0x80771ECA

	//rsa cryptographic stuff; always 2048-bit RSA keys for TPM compatibility
	tpm_rsakey_t brk; //{Bottle Root Key}_SEK (sealed)
	tpm_rsakey_t bsk; //{Bottle Signing Key}_BRK (bound)
	tpm_rsakey_t brk_public; //to be given to cap issuers to send caps
	tpm_rsakey_t bsk_public; //to be given to cap issuers to check quotes

	//aes cryptographic stuff; always 128-bit AES
	tpm_aeskey_t  bek; //{Bottle Encryption Key}_SRK (bound)

	//bottle configuration stuff
	uint32_t   flags;
	uint32_t   size; //number of slots in the bottle

	//matching check
	uint256_t  captable_signature; //{main table}_BSK
	uint256_t  header_signature; //{prevous header fields}_BSK

	//TODO: need some kind of password-check field

	uint32_t magic; //0x909ACE17
};

//TODO: which fields should be encrypted under BEK?
struct cap_t {
	uint128_t key; //password is a AES-128 key, generated by issuer
	uint128_t issuer; //issuer's AES-128 key
	uint64_t  oid; //object-ID field, used by issuer
	uint32_t  urights; //rights mask, used by issuer
	uint32_t  srights; //BottleCap rights word, determined by issuer
	uint128_t expiry; //cap expiry time, in 128-bit Unix time, determined by issuer
	//Note: expiry == 0 -> slot is empty
};

struct bottle_t {
	captable_header_t* header; //pointer to header structure
	cap_t* table; //pointer to beginning of cap table
	uint128_t password; //password which will be XOR'd into BEK
	//TODO: is the password thing a good idea?
};

//TODO: do I need to deal with TPM ownership credential?
//TODO: need to work out how to deal with PCR values, SINIT upgrades, etc
//TODO: need to work out how to prove to remote verifiers that this is a bottle
interface BottleCap {
	//BOTTLE CREATION/DELETION
	/**
	 * Initialises a new bottle, in the memory provided.
	 * header->size and header->flags should be filled in
	 * by the caller.
	 * 
	 * @param bottle Pointers to memory to be used for the
	 *               bottle header and cap table.
	 * @return Error code.
	 */
	int32_t bottle_init(in bottle_t bottle);
	//TODO: do we need some kind of destruction operation to
	//      reclaim TPM resources, like monotonic counters?

	//BOTTLE STATE FUNCTIONS
	/**
	 * Returns the number of free slots in the bottle.
	 * 
	 * @param bottle Pointers to memory to be used for the
	 *               bottle header and cap table.
	 * @param slots  The number of free slots in bottle.
	 * @return Error code.
	 */
	int32_t bottle_query_free_slots(in bottle_t bottle, out uint32_t slots);
	/**
	 * Deletes all caps in the bottle whose expiry dates
	 * are less than or equal to time.
	 * 
	 * @param bottle The bottle to operate on.
	 * @param time   The current time.
	 * @param slots  The new number of free slots in the bottle.
	 * @return Error code.
	 */
	int32_t bottle_expire(in bottle_t bottle, in uint128_t time, out uint32_t slots);

	//INTER-MACHINE BOTTLE MIGRATION FUNCTIONS
	/**
	 * Binds this bottle's BRK to a new TPM (including PCR values),
	 * allowing inter-machine migration.
	 * Does not change bottle in any way.
	 * 
	 * @param bottle The bottle to operate on.
	 * @param rsrk   The remote TPM's public SRK.
	 * @param slots  {BRK}_rSRK (TPM key blob)
	 * @return       Error code.
	 */
	int32_t bottle_export(in bottle_t bottle, in tpm_rsakey_t rsrk, out tpm_rsakey_t brk);
	/**
	 * Imports a bottle onto this machine: takes the bound BRK, and uses it to
	 * rewrite the bottle header so it is usable on this machine.
	 * 
	 * @param bottle The bottle to operate on.
	 * @param brk    {BRK}_SRK for this machine's TPM
	 * @return       Error code.
	 */
	int32_t bottle_import(in bottle_t bottle, in tpm_rsakey_t brk);

	//CAP INSERTION/DELETION FUNCTIONS
	/**
	 * Inserts a capability into the first free slot in the bottle.
	 * 
	 * @param bottle The bottle to operate on.
	 * @param cap    {The new cap.}_BRK (bound to PCR values)
	 * @param slot   The slot into which cap was inserted.
	 * @return        Error code.
	 */
	int32_t bottle_cap_add(in bottle_t bottle, in tpm_encrypted_cap_t cap, out uint32_t slot);
	/**
	 * Deletes a capability from the specified slot. If the slot is empty,
	 * this is a no-op.
	 * 
	 * @param bottle The bottle to operate on.
	 * @param slot   The slot to clear.
	 * @return       Error code.
	 */
	int32_t bottle_cap_delete(in bottle_t bottle, in uint32_t slot);

	//INTER-BOTTLE CAP MIGRATION
	/**
	 * Exports a capability for migration to another bottle. (The remote
	 * bottle uses bottle_cap_add to import it.)
	 * 
	 * @param bottle The bottle to operate on.
	 * @param slot   The slot containing the cap to export.
	 * @param rbrk   The public BRK for the bottle to export to.
	 * @param move   Whether to delete the original cap.
	 * @param cap    {Exported cap}_rBRK (bound to BottleCap PCR values)
	 * @return       Error code.
	 */
	int32_t bottle_cap_export(in bottle_t bottle, in uint32_t slot, in tpm_rsakey_t rbrk, in bool move, out tpm_encrypted_cap_t cap);

	//CAP INVOCATION FUNCTIONS
	//TODO: TPM quotes will be...interesting
};
